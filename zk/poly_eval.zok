import "./utils/casts/bool_array_to_u64_array" as bool_array_to_u64_array
import "./utils/casts/commits_to_u64" as commits_to_u64
import "./utils/casts/field_array_to_u64_array" as field_array_to_u64_array
import "./utils/casts/field_to_u64_array" as field_to_u64_array
import "./utils/casts/u64_array_to_bool_array" as u64_array_to_bool_array
import "./utils/casts/u64_array_to_field_array" as u64_array_to_field_array

from "ecc/babyjubjubParams" import BABYJUBJUB_PARAMS
import "ecc/proofOfOwnership" as proofOfOwnership
import "ecc/edwardsAdd" as edwardsAdd
import "ecc/edwardsScalarMult" as edwardsScalarMult
import "hashes/keccak/256bit" as keccak256
import "utils/pack/bool/pack256" as pack256
import "utils/pack/bool/unpack256" as unpack256

const u32 N = ? // To be filled in by the build script
const u32 N_TIMES_8 = N * 8

def computeSharedKey(field secretKey, field[2] pubKey, field[N][2] commits) -> field:
    
    field[2] exchanged_key = edwardsScalarMult(unpack256(secretKey), pubKey, BABYJUBJUB_PARAMS)
   
    u64[4] x = bool_array_to_u64_array(unpack256(exchanged_key[0]))
    u64[8] c = field_array_to_u64_array::<_,8>(commits[0])
   
    u64[4] key_hash = keccak256([...x, ...c])

    return pack256(u64_array_to_bool_array::<_,256>(key_hash))

def decrypt(field secretKey, field[2] pubKey, field[N][2] commits, field encryptedShare) -> field:
    return encryptedShare - computeSharedKey(secretKey, pubKey, commits)

/*
 * Evaluate the public commitment polynomial at the given index.
 * Analogous to https://github.com/dedis/kyber/blob/1a3d86c4f61cd7ac92bf14509aa887c728a5fe2a/share/poly.go#L339
 */
def evalPubPoly(field index, field[N][2] commits) -> field[2]:
    field[2] expected = BABYJUBJUB_PARAMS.INFINITY
    for u32 i in 0..N do
        expected = edwardsScalarMult(unpack256(index), expected, BABYJUBJUB_PARAMS)
        expected = edwardsAdd(expected, commits[N-1-i], BABYJUBJUB_PARAMS)
    endfor

    return expected

def main(private field[N][2] commits, private field secretKey, private field[2] pubKeyProofer, private field[2] pubKeyDealer, private field index, private field encryptedShare, field[2] hash) -> bool:
    assert(proofOfOwnership(pubKeyProofer, secretKey, BABYJUBJUB_PARAMS))

    u64[4] commitsHash = keccak256(commits_to_u64::<_,N_TIMES_8>(commits))

    assert(hash == u64_array_to_field_array::<_,2>(keccak256([
        ...commitsHash,
        ...field_array_to_u64_array::<_,8>(pubKeyProofer),
        ...field_array_to_u64_array::<_,8>(pubKeyDealer),
        ...field_to_u64_array(index),
        ...field_to_u64_array(encryptedShare)
    ])))

    /*
     * The shares on the blockchain are encrypted through one-time pad encryption,
     * using a combination of DH key exchange and keccak256 to generate a single-use key.
     */
    field share = decrypt(secretKey, pubKeyDealer, commits, encryptedShare)
    
    field[2] G = [BABYJUBJUB_PARAMS.Gu, BABYJUBJUB_PARAMS.Gv]
    field[2] actual = edwardsScalarMult(unpack256(share), G, BABYJUBJUB_PARAMS)
    field[2] expected = evalPubPoly(index, commits)

    return actual[0] != expected[0] || actual[1] != expected[1]